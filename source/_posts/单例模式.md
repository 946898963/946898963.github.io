---
title: 单例模式
date: 2016-06-14 17:31:36
categories:
- 技术
- 设计模式
tags:
- 设计模式
---

## 介绍

许多时候系统只允许拥有一个对象实例，例如一个系统只能有一个ImageLoader，里面又含有线程池，缓存系统，访问网络的操作，等等，比较消耗资源，因此没有理由创建多个实例，这种不能自由创建多个对象的情况，就是单例模式的使用情景。

## 使用场景

确保某个类的对象只有一个的场景，避免创建多个对象造成过多的内存消耗的情景，或者某种类型的对象只应该有且只有一个。例如创建一个对象消耗的资源过多，如果访问IO和数据库资源这时候就应该考虑使用单例模式。



## 代码实现：

### 饿汉模式：

```
public class Singleton {

    private static Singleton singleton = new Singleton();
    
    private Singleton(){
        
    }
    
    public static Singleton getInstance(){
        return singleton;
    }

}
```

类加载的时候，就完成了singleton的初始化，是线程安全的，但是不能够实现延迟加载，导致内存的利用率不高。

### 懒汉模式

```
public class Singleton {

    private static Singleton singleton ;

    private Singleton(){

    }

    public static synchronized  Singleton getInstance(){
        if(singleton==null){
            singleton = new Singleton();
        }
        return singleton;
    }

}
```

是线程安全的，但是因为每次调用的时候都要进行同步处理，所以效率比较低。

### 双检锁（DCL double check lock）

```
public class Singleton {

    private static Singleton singleton ;

    private Singleton(){

    }

    public static  Singleton getInstance(){
        if(singleton==null){
            
            synchronized (Singleton.class){
                if(singleton==null){
                    singleton = new Singleton();
                }
            }
           
        }
        return singleton;
    }

}

```

保证了线程安全，同时只会在一次的使用的时候进行同步操作，效率比较高。

第一层判断主要是为了避免在不必要的同步，第二层判断是为了在null的情况下创建实例。

但是这种写法有时候会出现DCL失效的问题。
singleton = new Singleton()被编译成多条的指令，大致做了三件事情：
> * 分配内存
> * 执行构造函数，初始化成员变量
> * 将singleton指向新分配的内存空间

java编译器允许乱序执行，同时由于在JDK 1.5 之前JVM中Cache,寄存器到主内存回写顺序的规定。上面的第二步跟第三步的顺序是无法保证的，也就是说可能会出现，第三步先执行，第二步后执行的情况，当A线程执行了第三步，切换到B线程执行，此时singleton不为空，返回直接返回singleton，使用的时候会出错。这就是DCL失效的问题。



### 静态内部类

```
public class Singleton {

    private Singleton(){

    }

    private static class SingletonHolder{
        private static final Singleton singleton = new Singleton();
    }
    
    public static  Singleton getInstance(){
        return SingletonHolder.singleton;
    }

}
```

线程安全的，同时实现了延迟加载，也修复了双检锁模式的问题。

### 枚举单例

```
public enum  Singleton {

    SINGLETON;

    public void doSometing(){
        System.out.println("wo shi mei ju lei!!!!");
    }

}
```

枚举类，写法简单，而且默认情况下是线程安全的，并且在任何情况下他都是一个单例。

上述的几种写法，在反序列化的时候，会出现重新创建对象实例的情况。但是枚举类的写法却不会。

### 使用容器实现单例模式

```
public class  SingletonManager {

    private static Map<String,Object> map = new Hashtable<>();

    private SingletonManager(){
        
    }
    
    public static void registerService(String key,Object instance){
        if(!map.containsKey(key)){
            map.put(key,instance);
        }
    }

    public static Object getService(String key){
        return map.get(key);
    }
}

```

在程序初始化的时候，将各种单例类放进一个统一个的管理类中进行管理，需要的时候通过key取出对应的单例。这种方式可以使我们管理多种类型的单例。同时使用同一的接口进行管理，降低了用户的使用的成本，同时在使用的过程中隐藏了内部的细节，降低了耦合性。

## 总结：

不论用那种方式实现单例，核心思想都是将构造函数私有化，同时通过一个静态的方法，获取唯一的一个实例。在获取的过程中必须保证线程安全的，同时防止在反序列化的过程中重新生成类的实例的情况。