---
title: 备忘录模式
date: 2016-06-16 11:08:39
categories:
- 技术
- 设计模式
tags:
- 设计模式
---

## 介绍

一种行为模式，用于保存对象的状态，并且在之后可以恢复到这种状态。备忘录模式的实现方式，需要保证被保存的对象的状态不能被对象从外部访问，目的是为了保护好这些被保存对象状态的完整性以及内部实现不向外部暴露。


## 使用场景

> * 需要保存某个对象在某一时刻的状态或者部分状态

> * 如果通过一个接口来让其他对象得到状态，将会暴露对象的实现的细节并破坏对象的封装性，一个对象不希望外部直接访问其内部状态，通过中间对象可以间接的访问其内部的状态。

## 角色

> * Originator
> * Memoto
> * CarreTaker


Originator  负责创建一个备忘录，可以记录恢复自身内部的状态。同时还可以根据需要，决定在Memoto中存储自身的那些状态。

Memoto  备忘录类，用于存储Originator内部的状态

CarreTaker  负责管理存储备忘录类，只能将备忘录类交个其他类，不能访问备忘录类。


## 简单实现

游戏的存档功能，将游戏的进度存储到本地文件系统或者数据库中，下次在进入时从本地加载进度，继续上一次的游戏。

备忘录类
```
public class Memoto {

    public int lifeValue ;
    public String weapon;
    public int guanka;


    @Override
    public String toString() {
        return "武器   "+weapon+"    关卡    "+guanka+"   生命   "+lifeValue;
    }

}
```

备忘录管理类
```
public class CareTaker {

    Memoto memo;

    public void archive(Memoto memo){
        this.memo=memo;
    }

    public Memo getMemo(){
        return memo;
    }

}
```

//游戏类
```
public class Game {

    private int lifeValue = 100;
    private String weapon = "dao";
    private int guanka = 10;


    public void play(){
        System.out.println("玩游戏"+"第"+guanka+"关");
        lifeValue-=10;
        guanka++;
        System.out.println("进入"+"第"+guanka+"关");
    }

    public void quit(){
        System.out.println("-----");
        System.out.println("推出前的游戏属性"+this.toString());
        System.out.println("退出游戏");
        System.out.println("-----");
    }

    @Override
    public String toString() {
        return "武器   "+weapon+"    关卡    "+guanka+"   生命   "+lifeValue;
    }

    public Memoto createMemo(){

        Memoto memo = new Memoto();
        memo.lifeValue = this.lifeValue;
        memo.weapon=this.weapon;
        memo.guanka=this.guanka;
        return memo;
    }

    public void restore(Memo memo){
        this.lifeValue=memo.lifeValue;
        this.guanka=memo.guanka;
        this.weapon=memo.weapon;
        System.out.println("恢复后的游戏属性"+this.toString());
    }

}
```

```
public static void main(String[] args) {
		Game game = new Game();
		//打游戏
		game.play();
		//存档
		MemoTaker memoTaker =  new MemoTaker();
		memoTaker.archive(game.createMemo());
		//退出游戏
		game.quit();
		//恢复游戏
		Game game2 = new Game();
		game2.restore(memoTaker.getMemo());

	}
```

上述过程大致有以下四步：
> *  开始游戏，闯关升级
> *  游戏退出前存档
> *  退出游戏
> *  重新启动游戏，从存档中恢复游戏进度


通过Memoto满足了对象存储功能的同时，也避免了外接对Game状态的直接访问，保证了封装特性。


