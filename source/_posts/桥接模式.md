---
title: 桥接模式
date: 2016-06-16 17:55:38
categories:
- 技术
- 设计模式
tags:
- 设计模式
---


## 介绍

结构型设计模式，跟生活中的桥接的作用类似，都起着连着两边的作用。
 
桥接模式的定义是将抽象部分与实现部分相互分离，使他们都能够相互独立的变化。

这里的两边就是指抽象部分跟实现部分。

## 使用场景 

一个类存在两个独立的维度，且这两个维度都需要进行扩展。

## 简单实现

喝咖啡，大杯加糖，大杯不加糖，小杯加糖，小杯不加糖，对一杯咖啡来说这四种变化实际上对应两种变化，一种是大杯小杯，一种是加糖不加糖。

抽象的咖啡类
```
public abstract class Coffee {

    protected CoffeeAdd coffeeAdd;

    public Coffee(CoffeeAdd coffeeAdd){
        this.coffeeAdd=coffeeAdd;
    }

    //咖啡具体是什么样子，由子类决定
    public abstract void makeCoffee();
}

```

添加类
```
public abstract class CoffeeAdd {

    /*
    * 具体往咖啡里添加什么由子类来决定
    *
    * @return  具体添加的东西
    * */
    public abstract String addSomthing();

}
```

具体的大杯小杯咖啡类
```
public class LargeCoffee extends Coffee {


    public LargeCoffee(CoffeeAdd coffeeAdd) {
        super(coffeeAdd);
    }

    @Override
    public void makeCoffee() {
        System.out.println("大杯的"+coffeeAdd+"咖啡");
    }
}
```

```
public class SmallCoffee extends Coffee {


    public SmallCoffee(CoffeeAdd coffeeAdd) {
        super(coffeeAdd);
    }

    @Override
    public void makeCoffee() {
        System.out.println("小杯的"+coffeeAdd+"咖啡");
    }
}

```

加糖不加糖
```
public class Oridinary extends CoffeeAdd {
    @Override
    public String addSomthing() {
        return "原味";
    }
}
```

```
public class Sugar extends CoffeeAdd {
    @Override
    public String addSomthing() {
        return "加糖";
    }
}
```

```
public static void main(String[] args) {

		Oridinary oridinary = new Oridinary();
        Sugar  sugar = new Sugar();

        //大杯原味
        LargeCoffee largeCoffeeO = new LargeCoffee(oridinary);
        largeCoffeeO.makeCoffee();
        
        //小杯原味
        SmallCoffee smallCoffeeO = new SmallCoffee(oridinary);
        smallCoffeeO.makeCoffee();

        //大杯加糖
        LargeCoffee largeCoffeeS = new LargeCoffee(sugar);
        largeCoffeeS.makeCoffee();

        //小杯加糖
        SmallCoffee smallCoffeeS = new SmallCoffee(sugar);
        smallCoffeeS.makeCoffee();

	}
```

如果后来咖啡厅推出了中杯的咖啡，只需要扩展Coffee即可。

```
public class MediaCoffee extends Coffee {

    public MediaCoffee(CoffeeAdd coffeeAdd) {
        super(coffeeAdd);
    }

    @Override
    public void makeCoffee() {
        System.out.println("中杯"+coffeeAdd.addSomthing()+"咖啡");
    }
}

```

客户端做出响应的修改

```
public static void main(String[] args) {

        Oridinary oridinary = new Oridinary();
        Sugar  sugar = new Sugar();

        //大杯原味
        LargeCoffee largeCoffeeO = new LargeCoffee(oridinary);
        largeCoffeeO.makeCoffee();

        //中杯原味
        MediaCoffee mediaCoffeeO = new MediaCoffee(oridinary);
        mediaCoffeeO.makeCoffee();
        
        
        //小杯原味
        SmallCoffee smallCoffeeO = new SmallCoffee(oridinary);
        smallCoffeeO.makeCoffee();

        //大杯加糖
        LargeCoffee largeCoffeeS = new LargeCoffee(sugar);
        largeCoffeeS.makeCoffee();

        //中杯加糖
        MediaCoffee mediaCoffeeS = new MediaCoffee(sugar);
        mediaCoffeeS.makeCoffee();
        
        //小杯加糖
        SmallCoffee smallCoffeeS = new SmallCoffee(sugar);
        smallCoffeeS.makeCoffee();

    }

```

同样的，为了增加咖啡的种类，我们也可以让CoffeeAdd类变化起来，增加更多的子类表示，诸如加奶，加蜂蜜，加盐等。从本例子中我们可以看出，不管Coffee变化了，还是CoffeeAdd变化了，其相对双方而言都是独立的么有什么过多的交集，两者之间的唯一的联系就是Coffee中保持对CoffeeAdd的引用，此乃两者之纽带，这就是桥接模式。

