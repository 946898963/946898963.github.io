---
title: 装饰模式
date: 2016-06-16 18:35:03
categories:
- 技术
- 设计模式
tags:
- 设计模式
---


## 介绍

结构型设计模式，也称为包装模式，使用一种对客户端透明的方式来动态的扩展对象的功能，是继承关系的一种替换方案之一。装饰模式无处不在，就拿人来说，人需要各式各样的衣着，但是不管你穿着什么，对于你来说本质是不变的，只不过是在外面批了一层的遮羞物，这就是装饰模式，装饰物不同，但是装饰的对象的本质是不变的。

动态的给对象增加一些功能职责。就增加功能来说，比生成子类的方式更加灵活。

## 使用场景

需要动态的且透明的增加类的功能的时候


## 简单实现

人穿衣服

人
```
public abstract class Person {
    /*
    * Person下有一个穿着的抽象方法
    * */
    public abstract void dressed();
}
```

男孩
```
public class Boy extends Person {
    @Override
    public void dressed() {
        System.out.println("穿了内衣内裤");
    }
}
```

男孩的装饰类
```
public class PersonCloth extends Person {

    protected  Person person;

    public PersonCloth(Person person){
        this.person=person;
    }

    @Override
    public void dressed() {
        person.dressed();
    }
}
```

便宜的衣服
```
public class CheapCloth extends PersonCloth {

    public CheapCloth(Person person) {
        super(person);
    }

    @Override
    public void dressed() {
        super.dressed();
        dressShorts();
    }

    private void dressShorts(){
        System.out.println("穿条短裤");
    }
}
```
贵的衣服
```
public class ExpensiveCloth extends PersonCloth {
    @Override
    public void dressed() {
        super.dressed();
        dressShirt();
        dressJean();
    }

    public ExpensiveCloth(Person person) {
        super(person);
    }


    private void dressShirt(){

        System.out.println("穿件T恤");
    }

    private void dressJean(){
        System.out.println("穿件牛仔裤");
    }
}

```

客户端
```
public void main(String[] args){

        Person boy = new Boy();

        //穿上便宜的衣服
        PersonCloth clothCheap = new CheapCloth(boy);
        clothCheap.dressed();

        //穿上贵的衣服
        PersonCloth clothExpensive = new ExpensiveCloth(boy);
        clothExpensive.dressed();

    }
```





