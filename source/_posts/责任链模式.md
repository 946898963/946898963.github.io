---
title: 责任链模式
date: 2016-06-17 11:37:40
categories:
- 技术
- 设计模式
tags:
- 设计模式
---


## 介绍

行为型设计模式之一。将链式结构应用于编程领域，每一个节点都看作是一个对象，每一个对象都拥有自己的不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止，我们将这样一种模式称之为责任链模式。

标准定义是这样的：使多个对象都有机会处理请求，从而避免了请求的发送者跟处理者之间的耦合的关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有对象处理它为止。

## 使用场景

> * 多个对象可以处理同一个请求，但具体由哪一个对象处理则在运行时候动态的决定。

> * 在请求处理者不明确的情况下，向多个对象提交处理请求。
> * 需要动态的指定一组对象处理请求。

## 代码实现

财务报销，组长，主管，部门经理，老板没人的报销权限不一致。

领导抽象类
```
public abstract class Leader {

    protected Leader nextHandler;

    public final void handleRequest(int money){

        if(money<=limit()){

            handle(money);

        }else {
            if(nextHandler!=null)
                nextHandler.handleRequest(money);
        }

    }


    //能处理的额度
    public abstract int limit();
    //报销了多少钱
    public abstract void handle(int money);
}
```

组长
```
public class GroupLeader extends Leader {


    @Override
    public int limit() {
        return 5000;
    }

    @Override
    public void handle(int money) {
       System.out.println("组长批复报销"+money+"元。");
    }
}
```

主管
```
public class Director extends Leader {
    @Override
    public int limit() {
        return 5000;
    }

    @Override
    public void handle(int money) {
        System.out.println("主管批复报销"+money+"元。");
    }
}
```

经理
```
public class Manager extends Leader {
    @Override
    public int limit() {
        return 10000;
    }

    @Override
    public void handle(int money) {
        System.out.println("经理批复报销"+money+"元。");
    }
}
```

老板
```
public class Boss extends Leader {
    @Override
    public int limit() {
        return Integer.MAX_VALUE;
    }

    @Override
    public void handle(int money) {
        System.out.println("老板批复报销"+money+"元。");
    }
}

```

测试
```
public static void main(String[] args){

        GroupLeader groupLeader = new GroupLeader();
        Director director = new Director();
        Manager manager = new Manager();
        Boss boss = new Boss();

        groupLeader.nextHandler=director;
        director.nextHandler=manager;
        manager.nextHandler=boss;

        groupLeader.handleRequest(15000);

    }
```

实际上我们是可以直接越过组长找主管报账的，这也是责任链模式的灵活之处，请求的发起者可以从责任链的任何一个节点开始，同时也可以改变责任链内部的传递规则，如主管不在，我们完全可以跨过主管从组长直接将请求转送给经理。

对于责任链中的一个处理者对象，其只有两个行为，一是处理请求，二是将请求转送给下一个节点，不允许某个对象处理了请求之后又将请求转送给上一个节点的情况。对于一条责任链来说，一个请求最终只有两种情况，一是被某个处理对象所处理，另一个是所有对象均未对其处理，对于前一种情况，我们称该责任链为纯的责任链，对于后一种情况，我们称该责任链为不纯的责任链，在实际的应用中， 我们所见到的责任链模式大多为不纯的责任链。